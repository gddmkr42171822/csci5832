'''
Robert Werthman
CSCI 5832
HW2 Sentiment Analysis

Naive-Bayes with add one smoothing
P(word|-) = (frequency of the word in negative reviews class + 1)/
            (total count of all words in negative reviews class + number of words in entire vocabulary of training set (V)) 
P(review|-) = log of the probability of each of the words being negative added together
'''
import re
import math
import random

# Words to remove that don't have any sentiment
#stopList = ['the','and','a','was','to','i','in','of','is','it','you','we','they',
#           'at','on', 'that', 'my', 'for', 'this']
stopList = []

def checkOutput(outputFile, answerFile):
    wrongReviews = 0
    answers = {}
    output = {}
    # Read in the IDs and tags from the correct answers file
    f = open(answerFile, 'r')
    for line in f:
        line = line.strip().split('\t')
        answers[line[0]] = line[1]
    f.close()
    # Read in the IDs and tags from the output generated by naive bayes
    f = open(outputFile)
    for line in f:
        line = line.strip().split('\t')
        output[line[0]] = line[1]
    # Check if each ID has the correct sentiment tag
    for key in output:
        if key in answers:
            if output[key] == answers[key]:
                pass
                #print "{0} is correct.".format(key)
            else:
                print '{0} output {1} answer {2}'.format(key, output[key], answers[key])
                #print "{0} is incorrect.".format(key)
                wrongReviews += 1
    #print 'Number of wrong IDs: {0}'.format(wrongReviews)
    return wrongReviews

def wordCount(file):
    '''
    Return a dictionary of the word counts in a file
    '''
    d = {}
    f = open(file, 'r')
    for line in f:
        # Remove end of punctuation
        line = re.sub('[.,!?():;]', '', line)
        # Make everything lowercase
        line = line.lower()
        # Split words on spaces in the line
        line = line.strip().split()
        # Remove the ID-.... from the line
        line = line[1:]
        # Create a dictionary with the key being the word and the value being the count
        for word in line:
            if word in d:
                d[word] += 1
            else:
                d[word] = 1
    '''
    # Remove any words from the stop list
    for word in stopList:
        d.pop(word)
    '''
    f.close()
    return d        

def gatherReviews(file):
    '''
    Return a dictionary of the reviews in a file
    '''
    d = {}
    f = open(file,'r')
    for line in f:
        # Remove end of punctuation
        line = re.sub('[.,!?():;]', '', line)
         # Make everything lowercase
        line = line.lower()
        # Split words on spaces in the line
        line = line.split()
        # Put review ID in the dictionary as key and rest of the words of the review as value
        d[line[0]] = line[1:]
        '''
        # Remove words in the review from the stop list
        cleanedList = [word for word in d[line[0]] if word not in stopList]
        d[line[0]] = cleanedList
        '''
        
    f.close()
    return d

def probabilityOfClass(reviewClass,review,vocabulary):
    '''
    Returns a list of probabilities for each word in a review given a class
    '''
    listOfProbabilities = []
    # Add up all the words in a review class
    totalCountOfWordsInClass = 0
    for word in reviewClass:
        totalCountOfWordsInClass += reviewClass[word]
    # Calculate the probability of each word given a review class
    for word in review:
        freqOfWordInClass = 0
        if word in reviewClass:
            freqOfWordInClass = reviewClass[word]
            #print word
        else:
            freqOfWordInClass = 0
        probabilityOfWord = ((freqOfWordInClass+1)*1.0)/((totalCountOfWordsInClass+len(vocabulary))*1.0)
        listOfProbabilities.append(math.log(probabilityOfWord))
    return listOfProbabilities
        
    
def copyFile(inputFile, outputFile):
    # Open the files
    input = open(inputFile, 'r')
    output = open(outputFile, 'w')
    # Read in the lines from the input file
    lines = input.readlines()
    # Write out the lines from the input file to the output file
    output.writelines(lines)
    # Close the files
    input.close()
    output.close()

def readFileIntoList(inputFile):
    f = open(inputFile, 'r')
    lines = f.readlines()
    f.close()
    return lines

def writeListToFile(outputFile, list, append):
    if append:
        f = open(outputFile, 'a')
    else:
        f = open(outputFile, 'w')
    f.writelines(list)
    f.close()

def createCrossValidationFiles(n):
    # Make copies of the original positive and negative review files
    copyFile('hotelPosT-train.txt', 'postrain-reviews.txt')
    copyFile('hoteNegT-train.txt', 'negtrain-reviews.txt')
    
    # Read the positive and negative reviews into two separate lists
    posReviews = readFileIntoList('postrain-reviews.txt')
    negReviews = readFileIntoList('negtrain-reviews.txt')    
    
    # Use n random reviews for the positive review test set
    # Use the remaining reviews for the positive training set
    testPosReviews = random.sample(posReviews, n)
    trainingPosReviews = [review for review in posReviews if review not in testPosReviews]
    
    # Use n random reviews for the negative review test set
    # Use the remaining reviews for the negative training set
    testNegReviews = random.sample(negReviews, n)
    trainingNegReviews = [review for review in negReviews if review not in testNegReviews]
    
    # Write the test reviews to the test set file
    writeListToFile('test-reviews.txt', testPosReviews, False)
    writeListToFile('test-reviews.txt', testNegReviews, True)
    
    # Write the training reviews to the test set file
    writeListToFile('postrain-reviews.txt', trainingPosReviews, False)
    writeListToFile('negtrain-reviews.txt', trainingNegReviews, False) 


def main():
    wrongReviews = 0.0
    n = 10
    x = 1
    for i in range(0,x):
        #createCrossValidationFiles(n)
        #createCrossValidationFiles(0)
        
        # Create a dictionary with all the words in the positive review set
        posWords = wordCount('postrain-reviews.txt')
        # Create a dictionary with all the words in the negative review set
        negWords = wordCount('negtrain-reviews.txt')
        # Create a dictionary of all the words in the training set
        vocabulary = posWords.copy()
        vocabulary.update(negWords)
        # Retrieve the reviews from a file and add them in a dictionary with the review ID as the key
        #reviews = gatherReviews('test-reviews.txt')
        # Create an output file for the sentiment analysis of the reviews
        f = open('werthman-robert-assgn2-out.txt', 'w')
        # Check if the reviews are positive or negative
        reviews = gatherReviews('HW2-testset.txt')
        for review in reviews:
            # Get a list of the log of the probabilities for each word in the review
            # for each sentiment class
            negProb = probabilityOfClass(negWords, reviews[review], vocabulary)
            posProb = probabilityOfClass(posWords, reviews[review], vocabulary)
            # Add the list of probabilities together for each class
            negProb = reduce(lambda x,y: x+y, negProb)
            posProb = reduce(lambda x,y: x+y, posProb)
            # Evaluate the sentiment of each review by comparing the probabilities of each class
            # for that review
            if posProb > negProb:
                f.write('{0}\tPOS\n'.format(review.upper()))
                #print "{0}. {1}\tPOS".format(line,review)
            elif negProb > posProb:
                f.write('{0}\tNEG\n'.format(review.upper()))
                #print "{0}. {1}\tNEG".format(line,review)
        f.close()
        
        wrongReviews += checkOutput('werthman-robert-assgn2-out.txt','answers.txt') 
    
    # For running training set as test set
    #totalTestReviews = (n+n)*x
    # For running real test set
    totalTestReviews = 50
    numCorrectReviews = totalTestReviews-wrongReviews
    print '{0} wrongly labeled reviews out of {1} total test reviews.'.format(wrongReviews, totalTestReviews)
    print 'Percent correct {0}'.format((numCorrectReviews/totalTestReviews)*100.0)  

if __name__ == '__main__':
    main()